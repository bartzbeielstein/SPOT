% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parSpot.R
\name{parSpot}
\alias{parSpot}
\title{Parallel Sequential Parameter Optimization}
\usage{
parSpot(x = NULL, fun, lower, upper, sequentialControlList = list(),
  parallelControlLists = list(list()), cl = NULL, nCores = NULL, ...)
}
\arguments{
\item{x}{is an optional start point (or set of start points), specified as a matrix. One row for each point, and one column for each optimized parameter.}

\item{fun}{is the objective function. It should receive a matrix x and return a matrix y. In case the function uses external code and is noisy, an additional seed parameter may be used, see the \code{control$seedFun} argument below for details.}

\item{lower}{is a vector that defines the lower boundary of search space. This determines also the dimensionality of the problem.}

\item{upper}{is a vector that defines the upper boundary of search space.}

\item{sequentialControlList}{is a list with control settings for spot. See \code{\link{spotControl}}.}

\item{parallelControlLists}{is a list of lists. Each list should contain a model + optimizer pair to be evaluated in parallel.
See \code{\link{spotControl}}.}

\item{...}{additional parameters passed to \code{fun}.}
}
\value{
This function returns a list with:
\describe{
	\item{\code{xbest}}{Parameters of the best found solution (matrix).}
	\item{\code{ybest}}{Objective function value of the best found solution (matrix).}
	\item{\code{x}}{Archive of all evaluation parameters (matrix).}
	\item{\code{y}}{Archive of the respective objective function values (matrix).}
	\item{\code{count}}{Number of performed objective function evaluations.}
	\item{\code{msg}}{Message specifying the reason of termination.}
	\item{\code{modelFit}}{The fit of the last build model, i.e., an object returned by the last call to the function specified by \code{control$model}.}
}
}
\description{
Parallel adaptation of the standard SPOT method.
This adaptation enables the user to specify multiple control lists to be evaluated in parallel.
In each control list, a model and model optimizer etc. is specified.
They are evaluated on a parallel cluster. The results are joined in a synchronization phase.
}
\examples{
res <- parSpot(x= NULL, funSphere, lower = c(-5,-5,-5), upper = c(5,5,5), 
    sequentialControlList = list(),
    parallelControlLists = list(list(model = buildKriging), 
                                list(model = buildRandomForest),
                                list(model = buildLM)))
}
